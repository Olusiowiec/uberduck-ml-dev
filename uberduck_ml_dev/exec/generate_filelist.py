# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/exec.generate_filelist.ipynb (unless otherwise specified).

__all__ = ['CACHE_LOCATION', 'STANDARD_MULTISPEAKER', 'STANDARD_SINGLESPEAKER', 'VCTK', 'FORMATS']

# Cell

import argparse
import os
from pathlib import Path

import sqlite3
from tqdm import tqdm

from ..data.cache import ensure_speaker_table, insert_speaker
from ..utils.utils import parse_vctk

CACHE_LOCATION = Path.home() / Path(".cache/uberduck/uberduck-ml-dev.db")

STANDARD_MULTISPEAKER = "standard-multispeaker"
STANDARD_SINGLESPEAKER = "standard-singlespeaker"
VCTK = "vctk"
FORMATS = [
    STANDARD_MULTISPEAKER,
    STANDARD_SINGLESPEAKER,
    VCTK,
]


def _convert_vctk(f, inp: str):
    vctk_data = parse_vctk(inp)
    speaker_id = 0
    conn = sqlite3.connect(str(CACHE_LOCATION))
    with conn:
        for speaker_name, speaker_data in tqdm(vctk_data.items()):
            insert_speaker(f.name, speaker_name, speaker_id, conn)
            speaker_out_path = Path(out_path) / speaker_name
            if not speaker_out_path.exists():
                os.makedirs(speaker_out_path)
            for transcription, flac_path in speaker_data:
                assert flac_path.endswith(".flac")
                wav_path = flac_path.replace(".flac", ".wav")
                convert_to_wav(flac_path, wav_path)
                full_path = Path(full_path).resolve()
                f.write(f"{full_path}|{transcription}|{speaker_id}\n")
            speaker_id += 1


def _convert_standard_multispeaker(f, inp: str):
    speaker_id = 0
    speakers = os.listdir(inp)
    conn = sqlite3.connect(str(CACHE_LOCATION))
    with conn:
        for speaker in tqdm(speakers):
            path = Path(inp) / Path(speaker)
            if not path.is_dir() or path.parts[-1].startswith("."):
                continue
            files = os.listdir(path)
            try:
                transcriptions, *_ = [f for f in files if f.endswith(".txt")]
            except:
                print(files)
                raise
            insert_speaker(f.name, speaker, speaker_id, conn)
            with (path / transcriptions).open("r") as txn_f:
                transcriptions = txn_f.readlines()
            for line in transcriptions:
                line = line.strip("\n")
                try:
                    line_path, line_txn, *_ = line.split("|")
                except Exception as e:
                    print(e)
                    print(line)
                    raise
                full_path = (path / line_path).resolve()
                f.write(f"{full_path}|{line_txn}|{speaker_id}\n")
            speaker_id += 1


def _generate_filelist(input_dataset, fmt, output_filelist):
    full_path = Path(output_filelist).resolve()
    ensure_speaker_table()
    with open(full_path, "w") as f:
        print(f.name)
        _convert_to_multispeaker(f, input_dataset, fmt)


def _convert_to_multispeaker(f, inp: str, fmt: str):
    assert fmt in [
        STANDARD_MULTISPEAKER,
        VCTK,
    ], f"Supported formats: {STANDARD_MULTISPEAKER}, {VCTK}"

    if fmt == STANDARD_MULTISPEAKER:
        return _convert_standard_multispeaker(f, inp)
    elif fmt == VCTK:
        return _convert_vctk(f, inp)

# Cell

from typing import List
import sys


def _parse_args(args: List[str]):
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--input", help="Path to input dataset directory")
    parser.add_argument(
        "-f", "--format", help="Input dataset format", default=STANDARD_MULTISPEAKER
    )
    parser.add_argument("-o", "--output", help="asdf", default="list.txt")
    return parser.parse_args(args)


try:
    from nbdev.imports import IN_NOTEBOOK
except:
    IN_NOTEBOOK = False

if __name__ == "__main__" and not IN_NOTEBOOK:
    args = _parse_args(sys.argv[1:])
    _generate_filelist(args.input, args.format, args.output)